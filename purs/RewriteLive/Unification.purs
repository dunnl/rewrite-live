module RewriteLive.Unification where

import Prelude
import Data.Either (Either(..))
import Data.List (List(..), singleton, length, zipWith)
import Data.Maybe (Maybe(..))
import Data.Tuple (Tuple(..))
import Data.Pair (Pair(..))
import RewriteLive.Expr ( Expr(..)
                        , AnnExpr(..)
                        , decorateNodes
                        , undecorateNodes
                        , class Substitute
                        , Sub
                        , substitute
                        , substitute1
                        )
import RewriteLive.Types (Equation (..), Equations, RwDir (..))

-- | # Utilities

-- | Try to pop off the head element of a list
popList :: forall a. List a -> Maybe (Tuple a (List a))
popList Nil = Nothing
popList (Cons a rest) = Just (Tuple a rest)

-- | # Types

-- | A flag indicating whether variables should be treated as
-- | bound variables (`Freeze`) or holes that can be unified (`Unfreeze`)
data Freeze = Freeze | Unfreeze

-- | An `Assignment` is a variable paired with an `Expression` to
-- | replace it with.
newtype Assignment =
  Assignment { variable :: String
             , assignment :: Expr
             }

-- | Apply a single-variable substitution to the right-hand side of an
-- | `Assignment`.
instance Substitute Assignment where
  substitute s (Assignment asgn) =
    Assignment (asgn {assignment = substitute s asgn.assignment})

-- | A set of `Assignment`s.
type Assignments = List Assignment

-- | Convert a set of `Assignments` into a `Sub`
asgnsToSub :: Assignments -> Sub
asgnsToSub Nil v = Var v
asgnsToSub (Cons (Assignment {variable, assignment}) rest) v =
  if variable == v
  then assignment
  else asgnsToSub rest v

-- | A state value maintained during unification.  The `Equations`
-- | represent unprocessed disagreement pairs. (Pedantically speaking
-- | they are only "potential" disagreement pairs, as the unprocessed
-- | pairs may contain pairs of equal variables, which would then be
-- | discarded by the unification engine.)  The `Assignments` describe
-- | the most general unifier (m.g.u.) as calculated thus far. Note
-- | that the m.g.u. can be updated as we process more disagreement
-- | pairs, and indeed we may find there is no m.g.u. at all if we
-- | find a disagreement pair we cannot resolve.
-- |
-- | **Invariant**: If `equations` is empty, the `assignments` should
-- | describe the m.g.u. of the original problem. If we find the
-- | problem is unsolvable, no `MGU_State` value should be computed.
type MGU_State =
  { assignments :: Assignments
  , equations :: Equations
  , configuration :: Pair Freeze
  }

-- | The result of unification. If the problem can be solved, an
-- | m.g.u. is provided as a set of `Assignments`. If the problem
-- | cannot be solved, a text value is provided which should explain
-- | the nature of the unresolvable conflict encountered during unification.
data MGU_Result =
    Solvable Assignments
  | Unsolvable String

-- | The result of taking a single unification step
data StepResult =
    -- Both sides of the disagreeing pair are equal, so we discarded
    -- the constaint
    StepDiscarded Equation
    -- A new assignment was created
  | StepNew Assignment
    -- Two functions were found equal, there is nothing interesting to say
  | StepPass
    -- The given equation is not unifiable and caused unification to
    -- fail
  | StepFail Equation

-- | An update message generated by one successful step in the
-- | unification procedure. `msg` should contain rendered HTML
-- | describing the actions taken during this step. `next` should
-- | contain the next state value to be fed to the next iteration.
type MGU_Update = { res :: StepResult
                  , next :: MGU_State
                  }

-- | The self-contained history of an execution of the unification
-- | algorithm.
-- |
-- | - `start` contains the initial set of equations
-- | - `history` contains a list of successful steps taken during unification.
-- |    This list will be empty if the procedure fails on the first step.
-- | - `final` contains the result of unification
type Trace =
  { start :: Equations
  , history :: List MGU_Update
  , final :: MGU_Result
  }

-- | Construct the initial state of the unification procedure from an
-- | equation between two expressions.
equationToInitialState :: Equation -> MGU_State
equationToInitialState eqn =
  { assignments: Nil
  , equations: singleton eqn
  , configuration: Pair Unfreeze Unfreeze
  }

-- | Given a current state, take one step in the unification
-- | procedure. First we pop off a disagreement pair from the stack of
-- | unprocessed equations (if no such disagreement pairs exist, we
-- | are done and unification is successful.). Then we process it
-- | according to a simple algorithm.
takeUnificationStep :: MGU_State -> Either MGU_Result MGU_Update
takeUnificationStep st =
  case (popList st.equations) of
    -- There are no non-assignment equations left, we are done
    Nothing ->
      Left (Solvable st.assignments)
    -- We have a new equation to consider
    Just (Tuple eqn rest) ->
      step eqn (st {equations = rest})
  where
    step :: Equation -> MGU_State ->  Either MGU_Result MGU_Update
    step eqn@(Equation {left, right}) state =
      case left of
        Var x1 ->
          case right of
            -- Var x = Var y
            Var x2 ->
              if x1 == x2
              -- This constraint is trivial, we can completely ignore it
              then Right { res: StepDiscarded eqn
                         , next: state }
              -- We have a var=var constraint, substitute and hang on to it
              else Right $ pushNewAssignment x1 (Var x2) state
            -- Var v = Node f args
            Node fn2 args2 ->
              Right $ pushNewAssignment x1 (Node fn2 args2) state
        Node fn1 args1 ->
          case right of
            -- Node f args = Var v
            Var x2 ->
              Right $ pushNewAssignment x2 (Node fn1 args1) state
            -- Node fn args = Node fn args
            Node fn2 args2 ->
              if (fn1 /= fn2)
                 -- Heads do not match
              then Left (Unsolvable "Heads unequal")
              else if (length args1 /= length args2)
                      -- Functions applied to different numbers of arguments
                   then Left (Unsolvable $ "Function " <> fn1 <> " applied to different numbers of arguments.")
                        -- Success, add new constraints to the stack
                   else Right { res: StepPass
                              , next: state { equations = (zipWith (\l r -> Equation {left: l, right: r}) args1 args2) <> state.equations}}
    pushNewAssignment :: String -> Expr -> MGU_State -> MGU_Update
    pushNewAssignment v e state =
      { res: StepPass
      , next: state { assignments =
                         Cons (Assignment {variable: v, assignment: e})
                         (substitute1 v e state.assignments)
                    , equations = substitute1 v e state.equations
                    }
      }

takeMatchingStep :: MGU_State -> Either MGU_Result MGU_Update
takeMatchingStep st =
  case (popList st.equations) of
    -- There are no non-assignment equations left, we are done
    Nothing ->
      Left (Solvable st.assignments)
    -- We have a new equation to consider
    Just (Tuple eqn rest) ->
      step eqn (st {equations = rest})
  where
    step :: Equation -> MGU_State ->  Either MGU_Result MGU_Update
    step eqn@(Equation {left, right}) state =
      case left of
        Var x1 ->
          case right of
            Var x2 ->
              if x1 == x2
              -- This constraint is trivial, we can completely ignore it
              then Right { res: StepDiscarded eqn
                         , next: state }
              -- We have a var=var constraint, substitute and hang on to it
              else Right $ pushNewAssignment x2 (Var x1) state
            -- Var v = Node f args
            Node _ _ ->
              Left (Unsolvable "Cannot unify function application with a bound variable.")
        Node fn1 args1 ->
          case right of
            -- Node f args = Var v
            Var x2 ->
              Right $ pushNewAssignment x2 (Node fn1 args1) state
            -- Node fn args = Node fn args
            Node fn2 args2 ->
              if (fn1 /= fn2)
                 -- Heads do not match
              then Left (Unsolvable "Heads unequal")
              else if (length args1 /= length args2)
                      -- Functions applied to different numbers of arguments
                   then Left (Unsolvable $ "Function " <> fn1 <> " applied to different numbers of arguments.")
                        -- Success, add new constraints to the stack
                   else Right { res: StepPass
                              , next: state { equations = (zipWith (\l r -> Equation {left: l, right: r}) args1 args2) <> state.equations}}
    pushNewAssignment :: String -> Expr -> MGU_State -> MGU_Update
    pushNewAssignment v e state =
      { res: StepPass
      , next: state { assignments =
                         Cons (Assignment {variable: v, assignment: e}) state.assignments
                         --(substitute1 v e state.assignments)
                    , equations = (\(Equation {left, right}) ->
                                    Equation {left, right: substitute1 v e right})
                                  <$> state.equations
                    }
      }

-- | Attempt to unify an equation bewteen two expressions.
tryUnifyingTrace :: Equation -> Trace
tryUnifyingTrace eqn =
  go (equationToInitialState eqn) Nil
  where
    go :: MGU_State -> List MGU_Update -> Trace
    go state history =
      case takeUnificationStep state of
        Left result ->
          { start: singleton eqn
          , history
          , final: result }
        Right update@{next} ->
          go next (history <> Cons update Nil)

-- | Attempt to unify an equation bewteen two expressions.
tryUnifying :: Equation -> MGU_Result
tryUnifying = _.final <<< tryUnifyingTrace

-- | Attempt to match
tryMatchingTrace :: Equation -> Trace
tryMatchingTrace eqn =
  go (equationToInitialState eqn) Nil
  where
    go :: MGU_State -> List MGU_Update -> Trace
    go state history =
      case takeMatchingStep state of
        Left result ->
          { start: singleton eqn
          , history
          , final: result }
        Right update@{next} ->
          go next (history <> Cons update Nil)

-- | Attempt to match
tryMatching :: Equation -> MGU_Result
tryMatching = _.final <<< tryMatchingTrace

-- | Given an expression, annotate the entire expression with
-- | information about where we could rewrite an `Equation` in
-- | direction `RwDir`
searchForAxioms :: Equation -> RwDir -> Expr -> AnnExpr (Tuple Int (Maybe Expr))
searchForAxioms (Equation eqn) dir expr =
  go (decorateNodes expr)
  where
    pattern_match = case dir of
      RwLeftToRight -> eqn.left
      RwRightToLeft -> eqn.right
    pattern_rewrite = case dir of
      RwLeftToRight -> eqn.right
      RwRightToLeft -> eqn.left
    go annexpr = case annexpr of
      AnnVar v -> AnnVar v
      cur@(AnnNode fn args uid) ->
        let result = tryMatching (Equation { left: undecorateNodes cur
                                           , right: pattern_match })
        in AnnNode fn (go <$> args) (Tuple uid (mnew result))
    mnew :: MGU_Result -> Maybe Expr
    mnew (Unsolvable _) = Nothing
    mnew (Solvable asgns) =
      Just (substitute (asgnsToSub asgns) pattern_rewrite)
