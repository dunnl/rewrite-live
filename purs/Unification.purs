module Unification where

import Data.String as Str
import Data.Array(fromFoldable)
import Data.Either (Either(..))
import Effect (Effect)
import Expr (Expr(..), expr_sub, exprToJSX, occurs_in, tryParseExpression, AnnExpr(..), lweird)
import ExprTextBox (exprTextBox)
import Misc hiding (fromFoldable)
import React.Basic.Classic (Component, JSX, createComponent, make)
import React.Basic.DOM as R
import React.Basic.DOM.Events (capture, targetValue)

-- | # Equations and assignments

-- | An `Equation` is a pair of expressions.
type Equation = Pair Expr

-- | A set of `Equation`s.
type Equations = List Equation

-- | An `Assignment` is a variable paired with an `Expression` to
-- | replace it with.
type Assignment = Record (variable :: String, assignment :: Expr)

-- | A set of `Assignment`s.
type Assignments = List Assignment

-- | Lift an `Assignment` to an `Equation` by applying `Var` to the
-- | variable.
asgnToEqn :: Assignment -> Equation
asgnToEqn asgn = Pair (Var asgn.variable) asgn.assignment

-- | ## Substitution and occurrence in equations and assignments

-- | Apply a single-variable substitution to the right-hand side of an
-- | `Assignment`.
sub_asgn :: String -> Expr -> Assignment -> Assignment
sub_asgn v e asgn = asgn {assignment = expr_sub v e asgn.assignment}

-- | Compute whether a given variable occurs anywhere in a set of
-- | equations
occurs_in_eqns :: String -> Equations -> Boolean
occurs_in_eqns v eqns =
  any (\p -> eitherOf (occurs_in v <$> p)) eqns

-- | Apply a single-variable substitution to a set of equations.  Both
-- | sides of each equation are substituted.
varElim_eqns :: String -> Expr -> Equations -> Equations
varElim_eqns v e eqns = (<$>) (expr_sub v e) <$> eqns

-- | Apply a single-variable substitution to a set of an assignments.
-- | Subsitution applies to the right-hand side (the assigned
-- | expression) only, ignoring the left-hand side (the variable).
varElim_asgns :: String -> Expr -> Assignments -> Assignments
varElim_asgns v e asgns =
  (\asgn -> asgn {assignment = expr_sub v e asgn.assignment}) <$> asgns

-- | ## JSX for equations and assignments

-- | Render an `Equation` as an HTML `div .eqn`.
renderEqn :: Equation -> JSX
renderEqn (Pair ex1 ex2) =
  R.div { className: "eqn",
          children: [ exprToJSX ex1
                    , R.text " = "
                    , exprToJSX ex2
                    ]
        }

-- | Render an `Equation` as an HTML `div .expr-inline`.

-- | This is pretty-printed per common convention, as a pair between
-- | angle brackets.
renderDsgp :: Equation -> JSX
renderDsgp (Pair ex1 ex2) =
  R.div { className: "expr-inline",
          children: [ R.text "\\(\\langle\\)",
                      exprToJSX ex1,
                      R.text ", ",
                      exprToJSX ex2,
                      R.text "\\(\\rangle\\)"
                      ]
        }

-- | Convert a set of `Equations` into an HTML ordered list.
renderEqns :: Equations -> JSX
renderEqns eqns =
  R.ol_ (fromFoldable $ (\x -> R.li {children:[x]}) <$> (renderDsgp <$> eqns))

-- | Render an `Assignment` into HTML.
renderAsgn :: Assignment -> JSX
renderAsgn ({variable: v, assignment: ex2}) =
  R.div { className: "eqn",
          children: [ exprToJSX (Var v),
                      R.text " \\(\\mapsto\\) ",
                      exprToJSX ex2 ]
        }
-- | Render a set of `Assignments` an HTML `ol`.
-- |
-- | # Most general unifier engine
renderAsgns :: Assignments -> JSX
renderAsgns asgns =
  R.ol_ (fromFoldable $ (renderAsgn <$> asgns))

-- | A state value maintained during unification.  The `Equations`
-- | represent unprocessed disagreement pairs. (Pedantically speaking
-- | they are only "potential" disagreement pairs, as the unprocessed
-- | pairs may contain pairs of equal variables, which would then be
-- | discarded by the unification engine.)  The `Assignments` describe
-- | the most general unifier (m.g.u.) as calculated thus far. Note
-- | that the m.g.u. can be updated as we process more disagreement
-- | pairs, and indeed we may find there is no m.g.u. at all if we
-- | find a disagreement pair we cannot resolve.
-- |
-- | **Invariant**: If `equations` is empty, the `assignments` should
-- | describe the m.g.u. of the original problem. If we find the
-- | problem is unsolvable, no `MGU_State` value should be computed.
type MGU_State = { assignments :: Assignments
                 , equations :: Equations
                 }

-- | The result of unification. If the problem can be solved, an
-- | m.g.u. is provided as a set of `Assignments`. If the problem
-- | cannot be solved, a text value is provided which should explain
-- | the nature of the unresolvable conflict encountered during unification.
data MGU_Result =
    Solvable Assignments
  | Unsolvable String

-- | An update message generated by one successful step in the
-- | unification procedure. `msg` should contain rendered HTML
-- | describing the actions taken during this step. `next` should
-- | contain the next state value to be fed to the next iteration.
type MGU_Update = Record (msg :: JSX, next :: MGU_State)

-- | Given a current state, take one step in the unification
-- | procedure. Operationally, we pop off a disagreement pair from the
-- | stack of unprocessed equations (if no such disagreement pairs
-- | exist, we are done and unification is successful.) and process
-- | it according to a simple algorithm.
takeUnificationStep :: MGU_State -> Either MGU_Result MGU_Update
takeUnificationStep st =
  case (popList st.equations) of
    Nothing -> -- There are no non-assignment equations left, we are done
      Left (Solvable st.assignments)
    Just (Tuple eqn rest) -> -- We have a new equation to consider
      processEquation eqn (st {equations = rest})

-- | Process one equation during unification.
processEquation :: Equation -> MGU_State ->  Either MGU_Result MGU_Update
processEquation eqn st =
  case eqn of
    input@(Pair (Var x) (Var y)) ->
      if x == y
      then -- This constraint is trivial, we can completely ignore it
        Right { next: st,
                msg: R.span { children:
                              [ R.text "Both variables of ",
                                renderDsgp input,
                                R.text " are equal, so this is not a disagreement and we can discard this constraint. "
                              ]}}
      else -- We have a var=var constraint, substitute and hang on to it
        Right $ pushNewAssignment x (Var y) st
    Pair (Node f args) (Var v) ->
      processEquation (Pair (Var v) (Node f args)) st
    Pair (Var v) (Node f args) ->
      Right $ pushNewAssignment v (Node f args) st
    Pair n1@(Node f1 args1) n2@(Node f2 args2) ->
      if (f1 /= f2)
      then Left (Unsolvable $ "There is no way to unify " <> show n1 <> " with " <> show n2 <> " because their heads are not equal.")
      else if (length args1 /= length args2) then
             Left $ Unsolvable $ "There is no way to unify " <> show n1 <> " with " <> show n2
             <> ". The heads match but they are applied to different numbers of arguments"
           else Right { msg: R.text $
                        "Unification of " <> show n1 <> " with " <> show n2
                        <> " induces new potential disagreement pairs for corresponding arguments. "
                        <> "We push these new constraints back onto the stack.",
                        next: st {equations = (zipWith Pair args1 args2) <> st.equations}}

-- | Finish one successful step of unification that has resulted in a
-- | new assignment of an expression to a variable. In the `next`
-- | state returned in the `MGU_Update`, we perform the associated
-- | substitution in all remaining disagreement pairs as well as
-- | throughout the current value of the m.g.u. Finally, we add the
-- | new assignment to m.g.u.
pushNewAssignment :: String -> Expr -> MGU_State -> MGU_Update
pushNewAssignment v e st =
  { msg:
    (R.text $ "This disagreement pair is unified by the following substitution:") <>
    (R.text $ "\\[" <> v <> "\\mapsto " <> show e <> "\\]") <>
    (R.text $ "We apply this substitution to the m.g.u. and to the remaining disagreement pairs on the stack."),
    next:
    { assignments: Cons {variable: v, assignment: e} (varElim_asgns v e st.assignments),
      equations: varElim_eqns v e st.equations
    }}

-- | The self-contained history of an execution of the unification
-- | algorithm.
-- |
-- | - `start` contains the initial set of equations
-- | - `history` contains a list of successful steps taken during unification.
-- |    This list will be empty if the procedure fails on the first step.
-- | - `final` contains the result of unification
type Trace =
  Record (start :: Equations,
          history :: List MGU_Update,
          final :: MGU_Result)

-- | Construct the initial state of the unification procedure from an
-- | equation between two expressions.
equationToInitialState :: Equation -> MGU_State
equationToInitialState eqn =
  {assignments: Nil, equations: singleton eqn}

-- | Attempt to unify an equation bewteen two expressions.
solveUnificationProblem :: Equation -> Trace
solveUnificationProblem eqn =
  go (equationToInitialState eqn) Nil
  where
    go :: MGU_State -> List MGU_Update -> Trace
    go st history =
      case takeUnificationStep st of
        Left result -> { start: singleton eqn
                       , history
                       , final: result }
        Right {msg, next} ->
          go next (history <> (Cons {msg, next} Nil))

-- | Given an expression, annotate the entire expression with the
-- | results of unification.
unifyAll :: Expr -> Int -> Expr -> AnnExpr (Tuple Int MGU_Result)
unifyAll e_uni n e_main =
  case e_main of
    Var v -> AVar v
    Node fn args ->
      let mgu_here = _.final $ solveUnificationProblem (Pair e_uni e_main)
      in ANode fn (lweird (unifyAll e_uni) (n+1) args) (Tuple n mgu_here)

-- | I am a weird function.
weird :: Int -> Expr -> AnnExpr Int
weird n (Var v) = AVar v
weird n (Node fn args) = ANode fn (lweird weird (n + 1) args) n

-- | ## Rendering values

-- | ### Helpers

-- | Display an array of `div .column` values inside a single `div .columns`.
inRowOfColumns :: String -> Array JSX -> JSX
inRowOfColumns classes children =
    R.div { className: "columns" <>
            (if Str.length classes > 0
             then " " <> classes
             else mempty)
          , children
          }

-- | Render some content as a `div .column`.
inColumn :: String -> Array JSX -> JSX
inColumn classes children =
  R.div { className: "column" <>
          (if Str.length classes > 0
           then " " <> classes
           else mempty)
        , children
        }

-- | ### Renderers

-- | Render a `MGU_State` as a HTML `div .box`
renderMguState :: MGU_State -> JSX
renderMguState state =
  R.div { className: "box"
        , children:
          [ inRowOfColumns "mgustate"
            [ inColumn "is-three-fifths"
              [ R.h5 { className: "has-text-weight-bold",
                       children: [R.text "Potential disagreement pairs"]}
              , renderEqns state.equations]
            , inColumn ""
              [ R.h5 { className: "has-text-weight-bold",
                       children: [R.text "Current m.g.u. \\(\\sigma\\)"] }
              , renderAsgns state.assignments
              ]
            ]
          ]
        }


-- | Given a set of `Equations` used as the input for unification,
-- | render an HTML `div .columns` displaying information about the
-- | start of the problem.
renderMguStart :: Equations -> JSX
renderMguStart eqns =
  inRowOfColumns "is-centered"
  [ inColumn "" [update]
  , inColumn "" [state]
  ]
  where
    start_msg = "Attempting to compute a most general unifier for the following system."
    update =  R.div { className: "update"
                    , children: [R.text start_msg]
                    }
    state = renderMguState
            { assignments: Nil
            , equations: eqns
            }


-- | Render the `MGU_Result` resulting from a run of the unification problem.
-- | render an HTML `div .columns` displaying information about the
-- | conclusion of the problem.
renderMguResult :: MGU_Result -> JSX
renderMguResult res =
  inRowOfColumns "is-centered" $
  [ inColumn "" $
    [ R.div { className: "update"
            , children:
              [ case res of
                   Solvable asgns ->
                     R.text "The equation is solvable according to the displayed unifier."
                   Unsolvable str -> R.text "The system cannot be unified."
              ]
            }
    ]
  ]

para :: String -> JSX
para msg =
  R.p { children: [R.text msg] }

-- | Render the `MGU_Result` resulting from a run of the unification problem.
-- | as a nice summary.
renderMguSummary :: MGU_Result -> JSX
renderMguSummary res =
  inRowOfColumns "is-centered" $
  [ inColumn "is-half" $
    [
    case res of
      Solvable asgns ->
        R.article { className: "message is-success"
                  , children:
                    [ R.div { className: "message-header"
                            , children: [para "Success"]
                            }
                    , R.div { className: "message-body has-text-centered"
                            , children:
                              [ para "This problem has the following most general unifier:"
                              , renderAsgns asgns
                              ]
                            }
                    ]
                  }

      Unsolvable _ ->
        R.article { className: "message is-danger"
                  , children:
                    [ R.div { className: "message-header"
                            , children: [para "Failure"]
                            }
                    , R.div { className: "message-body has-text-centered"
                            , children: [para "This problem is not unifiable."]
                            }
                    ]
                  }
    ]
  ]


renderMguUpdate :: MGU_Update -> JSX
renderMguUpdate {msg, next} =
  R.div { className: "columns is-centered",
          children:
          [ R.div { className: "column",
                    children: [R.div { className: "update",
                                       children: [msg]}]},
            R.div { className: "column",
                    children: [renderMguState next]}]}

renderTrace :: Trace -> JSX
renderTrace trace =
  renderMguSummary trace.final <>
  renderMguStart trace.start <>
  foldMap renderMguUpdate trace.history <>
  renderMguResult trace.final

-- | # The unification app

type State =
  Record ( e1 :: String
         , e2 :: String
         )

-- | Compute whether the `State` constitutes a well-formed `Equation`
stateEquation :: State -> Maybe Equation
stateEquation {e1, e2} = do
  e1' <- tryParseExpression e1
  e2' <- tryParseExpression e2
  pure (Pair e1' e2')


-- | The initial state of the app is a set of two empty textboxes.
initialState :: State
initialState =
   { e1: ""
   , e2: ""
   }

-- | Render the `State` of the app
renderState :: State -> JSX
renderState st =
  inRowOfColumns "is-centered"
  [ inColumn ""
    [ case stateEquation st of
         Nothing ->
           R.text "Enter two expressions to compute their most general unifier, if there is one."
         Just eqn ->
           renderTrace (solveUnificationProblem eqn)
    ]
  ]

foreign import typeset :: Effect Unit

renderUnificationDemo :: Unit -> JSX
renderUnificationDemo = make (createComponent "UnificationDemo")
  { initialState: initialState
  , didUpdate: \_ _ -> typeset
  , render: \self ->
    inRowOfColumns "is-centered"
    [ inColumn "is-half"
      [ exprTextBox { label: "Expression 1"
                    , value: self.state.e1
                    , onChange: capture targetValue $ \targetValue ->
                      self.setState $ \s -> s { e1 = fromMaybe "" targetValue }
                    }
      , exprTextBox { label: "Expression 2"
                    , value: self.state.e2
                    , onChange: capture targetValue $ \targetValue ->
                      self.setState $ \s -> s { e2 = fromMaybe "" targetValue }
                    }
      ]
    ] <>
    renderState self.state
  }
